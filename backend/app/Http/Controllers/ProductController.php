<?php

namespace App\Http\Controllers;
use App\Models\Product_images_tagging;
use App\Models\Product_tagging_details;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Log;
use Illuminate\Http\Request;
use Illuminate\Pagination\LengthAwarePaginator;
use Illuminate\Support\Collection;

use App\Models\Products;
use App\Models\Price_setup;
use App\Models\Product_images;

use App\Models\POrder_detail;
use App\Models\Grn_details;
use App\Models\Inventory_tblmaster;
use App\Models\Orders;
use App\Models\Invoice_detail;
use App\Models\Product_type;
use App\Models\Manufacturer;
use App\Models\Brands;
use App\Models\Series;
use App\Models\Genre;
use App\Models\Product_tagging;
use App\Models\Customer_group;
use App\Models\ISSettings;
use App\Models\Shipout_items;
use App\Models\Inventory_allocation;
use App\Models\Internal_Transfer;
use App\Models\Stock_take_master;
use App\Models\Stock_take_detail;
use App\Models\Operator;
use App\Models\Grn_master;

use App\Services\AutoGenerated;
use App\Services\ProductStatusService;

use App\Events\ProductEvent;
use App\Events\LogEvent;
use App\Events\GRNEvent;
use App\Events\InventoryEvent;
use App\Events\AllocationEvent;

use Carbon\Carbon;
use App\Http\Controllers\GlobalController;

use Illuminate\Support\Facades\Storage;
class ProductController extends Controller{

    protected $language;

    public function getAllProducts(Request $request){
        $perPage = (int) $request->input('per_page', 15);
        $search = $request->input('search', '');

        $query = Products::with(['priceSetup', 'genres', 'images','priceList','series','supplier'])
            ->select('*')
            ->selectSub(function ($query) {
                $query->from('t_inventory_tblmaster')
                    ->selectRaw('COALESCE(SUM(qty - allocated_qty), 0)')
                    ->whereColumn('product_id', 'm_products.id');
            }, 'available_qty')
            ->where('is_deleted', 0)
            ->where('is_import', 0)
            ->orderBy('id', 'desc');

        if ($search) {
            $query->where(function ($q) use ($search) {
                $q->where('product_code', 'like', "%{$search}%")
                ->orWhere('product_title_en', 'like', "%{$search}%")
                ->orWhere('product_title_cn', 'like', "%{$search}%")
                ->orWhere('product_status', 'like', "%{$search}%")
                ->orWhere('rwarehouse', 'like', "%{$search}%");
            });
        }

        $result = $perPage === -1 ? $query->get() : $query->paginate($perPage);

        $transform = function ($product) {
            $priceSetup = $product->priceSetup->firstWhere('customer_group_id', 6);
            $product->price_currency = optional($priceSetup)->currency;
            $product->retail_price = optional($priceSetup)->retail_price;
            $product->preorder_price = optional($priceSetup)->preorder_price;
            $product->deposit = optional($priceSetup)->deposit;
            $product->product_thumbnail = optional(value: $product->images->firstWhere('type', 'thumbnail'))->path;
            // Adjust available_qty based on product_status
            $product->available_qty = $product->product_status === 'In-Stock'
                ? $product->available_qty ?? 0
                : $product->rem_qty;
            
            return $product;
        };
        $data = $perPage === -1
            ? $result->map($transform)
            : tap($result)->getCollection()->transform($transform);

        return response()->json([
            'success' => true,
            'message' => 'success',
            'product' => $perPage === -1
                ? [
                    'current_page' => 1,
                    'data' => $data,
                    'last_page' => 1,
                    'per_page' => $data->count(),
                    'total' => $data->count(),
                ]
                : $result,
        ]);
    }
    public function getAllProductsImports(Request $request){
        $perPage = (int) $request->input('per_page', 15);
        $search = $request->input('search', '');
        $query = Products::with(['priceSetup', 'genres', 'images','priceList','series','supplier'])
            ->select('*')
            ->selectSub(function ($query) {
                $query->from('t_inventory_tblmaster')
                    ->selectRaw('COALESCE(SUM(qty - allocated_qty), 0)')
                    ->whereColumn('product_id', 'm_products.id');
            }, 'available_qty')
            ->where('is_deleted', 0)
            ->where('is_import',1)
            ->orderBy('id', 'desc');

        if ($search) {
            $query->where(function ($q) use ($search) {
                $q->where('product_code', 'like', "%{$search}%")
                ->orWhere('product_title_en', 'like', "%{$search}%")
                ->orWhere('product_title_cn', 'like', "%{$search}%")
                ->orWhere('product_status', 'like', "%{$search}%")
                ->orWhere('rwarehouse', 'like', "%{$search}%");
            });
        }

        $result = $perPage === -1 ? $query->get() : $query->paginate($perPage);

        $transform = function ($product) {
            $priceSetup = $product->priceSetup->firstWhere('customer_group_id', 6);
            $product->price_currency = optional($priceSetup)->currency;
            $product->retail_price = optional($priceSetup)->retail_price;
            $product->preorder_price = optional($priceSetup)->preorder_price;
            $product->deposit = optional($priceSetup)->deposit;
            $product->product_thumbnail = optional(value: $product->images->firstWhere('type', 'thumbnail'))->path;
            // Adjust available_qty based on product_status
            $product->available_qty = $product->product_status === 'In-Stock'
                ? $product->available_qty ?? 0
                : $product->rem_qty;
            
            return $product;
        };
        $data = $perPage === -1
            ? $result->map($transform)
            : tap($result)->getCollection()->transform($transform);

        return response()->json([
            'success' => true,
            'message' => 'success',
            'product' => $perPage === -1
                ? [
                    'current_page' => 1,
                    'data' => $data,
                    'last_page' => 1,
                    'per_page' => $data->count(),
                    'total' => $data->count(),
                ]
                : $result,
        ]);
    }
    public function getAllProductsBySort(Request $request){
        $perPage = (int) $request->input('per_page', 10);
        $search = $request->input('search', '');
        $sortId = $request->input('sortId', []);
        // If sortId is not an array, convert it to an array
        if (!is_array($sortId)) {
            $sortId = explode(',', $sortId);  // Convert comma-separated string to array
        }

        $query = Products::with(['priceSetup', 'genres', 'images','priceList','series','supplier'])
            ->select('*')
            ->selectSub(function ($query) {
                $query->from('t_inventory_tblmaster')
                    ->selectRaw('COALESCE(SUM(qty - allocated_qty), 0)')
                    ->whereColumn('product_id', 'm_products.id');
            }, 'available_qty')
            ->where('is_deleted', 0);

        // If 'sortId' is provided, modify the order query to prioritize these IDs
        if (!empty($sortId)) {
            // Apply the FIELD(id, ...) sorting first, without the second `orderBy('id', 'desc')`
            $query->orderByRaw("FIELD(id, " . implode(',', $sortId) . ") DESC");
        } else {
            // If no sortId is provided, use default descending order by `id`
            $query->orderBy('id', 'desc');
        }

        if ($search) {
            $query->where(function ($q) use ($search) {
                $q->where('product_code', 'like', "%{$search}%")
                ->orWhere('product_title_en', 'like', "%{$search}%")
                ->orWhere('product_title_cn', 'like', "%{$search}%")
                ->orWhere('product_status', 'like', "%{$search}%")
                ->orWhere('rwarehouse', 'like', "%{$search}%");
            });
        }

        $result = $perPage === -1 ? $query->get() : $query->paginate($perPage);

        $transform = function ($product) {
            $priceSetup = $product->priceSetup->firstWhere('customer_group_id', 6);
            $product->price_currency = optional($priceSetup)->currency;
            $product->retail_price = optional($priceSetup)->retail_price;
            $product->preorder_price = optional($priceSetup)->preorder_price;
            $product->deposit = optional($priceSetup)->deposit;
            $product->product_thumbnail = optional(value: $product->images->firstWhere('type', 'thumbnail'))->path;
            // Adjust available_qty based on product_status
            $product->available_qty = $product->product_status === 'In-Stock'
                ? $product->available_qty ?? 0
                : $product->rem_qty;
            
            return $product;
        };
        $data = $perPage === -1
            ? $result->map($transform)
            : tap($result)->getCollection()->transform($transform);

        return response()->json([
            'success' => true,
            'message' => 'success',
            'product' => $perPage === -1
                ? [
                    'current_page' => 1,
                    'data' => $data,
                    'last_page' => 1,
                    'per_page' => $data->count(),
                    'total' => $data->count(),
                ]
                : $result,
        ]);
    }
    public function getAllProductsByCode(Request $request){
        $perPage = (int) $request->input('per_page', 15);
        $search = $request->input('search', '');

        $query = Products::with(['priceSetup', 'genres', 'images','priceList','series','supplier'])
            ->select('*')
            ->selectSub(function ($query) {
                $query->from('t_inventory_tblmaster')
                    ->selectRaw('COALESCE(SUM(qty - allocated_qty), 0)')
                    ->whereColumn('product_id', 'm_products.id');
            }, 'available_qty')
            ->where('is_deleted', 0)  // only non-deleted products
            ->orderBy('id', 'desc');

        if ($search) {
            $query->where(function ($q) use ($search) {
                $q->where('product_code', 'like', "%{$search}%");
            });
        }

        $result = $perPage === -1 ? $query->get() : $query->paginate($perPage);

        $transform = function ($product) {
            $product->price_currency = optional($product->priceSetup)->currency;
            $product->retail_price = optional($product->priceSetup)->retail_price;
            $product->preorder_price = optional($product->priceSetup)->preorder_price;
            $product->deposit = optional($product->priceSetup)->deposit;
            $product->product_thumbnail = optional(value: $product->images->firstWhere('type', 'thumbnail'))->path;
            // Adjust available_qty based on product_status
            $product->available_qty = $product->product_status === 'In-Stock'
                ? $product->available_qty ?? 0
                : $product->rem_qty;
            
            return $product;
        };
        $data = $perPage === -1
            ? $result->map($transform)
            : tap($result)->getCollection()->transform($transform);

        return response()->json([
            'success' => true,
            'message' => 'success',
            'product' => $perPage === -1
                ? [
                    'current_page' => 1,
                    'data' => $data,
                    'last_page' => 1,
                    'per_page' => $data->count(),
                    'total' => $data->count(),
                ]
                : $result,
        ]);
    }
    public function getArchiveProducts(Request $request){
        $perPage = (int) $request->input('per_page', 15);
        $search = $request->input('search', '');

        $query = Products::with(['priceSetup', 'genres', 'images'])
            ->where('is_deleted', 1)  // only non-deleted products
            ->orderBy('id', 'desc');

        if ($search) {
            $query->where(function ($q) use ($search) {
                $q->where('product_code', 'like', "%{$search}%")
                ->orWhere('product_title_en', 'like', "%{$search}%")
                ->orWhere('product_title_cn', 'like', "%{$search}%")
                ->orWhere('product_status', 'like', "%{$search}%")
                ->orWhere('rwarehouse', 'like', "%{$search}%");
            });
        }

        $result = $perPage === -1 ? $query->get() : $query->paginate($perPage);

        $transform = function ($product) {
            $product->price_currency = optional($product->priceSetup)->currency;
            $product->retail_price = optional($product->priceSetup)->retail_price;
            $product->preorder_price = optional($product->priceSetup)->preorder_price;
            $product->deposit = optional($product->priceSetup)->deposit;
            $product->product_thumbnail = optional($product->images->firstWhere('type', 'thumbnail'))->path;
            return $product;
        };

        $data = $perPage === -1
            ? $result->map($transform)
            : tap($result)->getCollection()->transform($transform);

        return response()->json([
            'success' => true,
            'message' => 'success',
            'product' => $perPage === -1
                ? [
                    'current_page' => 1,
                    'data' => $data,
                    'last_page' => 1,
                    'per_page' => $data->count(),
                    'total' => $data->count(),
                ]
                : $result,
        ]);
    }
    public function getProductTagList(Request $request){
        $flag = $request->input('flag');
        $recordID = $request->input('record_id');
        $search = $request->input('search');
        $perPage = (int) $request->input('per_page', 10);
        $page = (int) $request->input('page', 1);

        $query = Product_tagging::with(['details.product.priceSetup','images']);

        if ($flag == 2 && $recordID) {
            $query->where('id', $recordID);
        }

        if (!empty($search)) {
            $query->where(function ($q) use ($search) {
                // Search on product_tagging table itself
                $q->where('product_code', 'like', "%{$search}%")
                ->orWhere('product_title_en', 'like', "%{$search}%")
                ->orWhere('product_title_cn', 'like', "%{$search}%")
                ->orWhere('old_product_code', 'like', "%{$search}%");
            })
            ->orWhereHas('details.product', function ($q) use ($search) {
                // Search inside related products
                $q->where('product_code', 'like', "%{$search}%")
                ->orWhere('product_title_en', 'like', "%{$search}%")
                ->orWhere('product_title_cn', 'like', "%{$search}%");
            });
        }

        // Apply pagination
        $taggings = $query->orderBy('id', 'desc')->paginate($perPage, ['*'], 'page', $page);

        // Transform each item in the paginated collection
        $taggings->getCollection()->transform(function ($tagging) {
            $products = $tagging->details->pluck('product')->filter(); // removes nulls

            $firstProduct = $products->first();
            $preorderStart = optional($firstProduct)->preorder_start_date;
            $preorderEnd = optional($firstProduct)->preorder_end_date;

            $currency = '';
            $retailPrice = 0;
            $preorderPrice = 0;
            $deposit = 0;

            foreach ($products as $product) {
                $price = $product->priceSetup;
                if ($price) {
                    $currency = $price->currency;
                    $retailPrice += $price->retail_price;
                    $preorderPrice += $price->preorder_price;
                    $deposit += $price->deposit;
                }
            }

            $taggingThumbnail = optional($tagging->images->firstWhere('type', 'thumbnail'))->path;

            return [
                'id' => $tagging->id,
                'product_code' => $tagging->product_code,
                'old_product_code' => $tagging->old_product_code,
                'product_title_en' => $tagging->product_title_en,
                'product_title_cn' => $tagging->product_title_cn,
                'is_tnt' => $tagging->is_tnt,
                'is_activate_banner' => $tagging->is_activate_banner,
                'preorder_start_date' => $preorderStart,
                'preorder_end_date' => $preorderEnd,
                'currency' => $currency,
                'retail_price' => $retailPrice,
                'preorder_price' => $preorderPrice,
                'deposit' => $deposit,
                'tagging_thumbnail' => $taggingThumbnail,
            ];
        });

        return response()->json([
            'success' => true,
            'message' => 'Product tagging data loaded.',
            'product' => $taggings, // This matches expected frontend key
        ]);
    }
    public function getTaggingDetails($id){
        // Find the Product_tagging record with related details and products
        $tagging = Product_tagging::with(['details.product.images', 'details.product.priceSetup'])
            ->find($id);

        if (!$tagging) {
            return response()->json([
                'success' => false,
                'message' => 'Product tagging not found.',
            ]);
        }

        $details = $tagging->details->map(function ($detail) {
            $product = $detail->product;

            if (!$product) {
                return null; // or skip this detail if product is missing
            }

            return [
                'id' => $detail->id,
                'product_id' => $product->id,
                'product_code' => $product->product_code,
                'product_title_en' => $product->product_title_en,
                'product_title_cn' => $product->product_title_cn,
                'preorder_start_date' => $product->preorder_start_date,
                'preorder_end_date' => $product->preorder_end_date,
                'item_cost' => $product->item_cost,
                'retail_price' => optional($product->priceSetup)->retail_price,
                'preorder_price' => optional($product->priceSetup)->preorder_price,
                'deposit' => optional($product->priceSetup)->deposit,
                'currency' => optional($product->priceSetup)->currency,
                'thumbnail' => optional($product->images->firstWhere('type', 'thumbnail'))->path,
            ];
        });

        return response()->json([
            'success' => true,
            'message' => 'Tagging details loaded.',
            'product' => $details,
        ]);
    }
    public function delProduct(Request $request){
        $ids = $request->input('ids');
        $type = $request->input('type');

        if (!is_array($ids) || empty($ids)) {
            return response()->json(['message' => 'No product IDs provided'], 400);
        }

        foreach ($ids as $id) {
            $product = Products::find($id);
            if (!$product) continue;

            if ($type === 'soft') {

                $globalController = new GlobalController();
                $globalController->logAction(
                    'Products', 'm_products',
                    'delete',
                    'Product Code : ' . $product->product_code
                );
                $product->is_deleted = 1;
                $product->save();
            } elseif ($type === 'hard') {

                $globalController = new GlobalController();
                $globalController->logAction(
                    'Products Archive', 'm_products',
                    'delete',
                    'Product Code : ' . $product->product_code
                );

                $product->delete();
            } elseif ($type === 'restore') {

                $globalController = new GlobalController();
                $globalController->logAction(
                    'Products Archive', 'm_products',
                    'delete',
                    'Product Code : ' . $product->product_code
                );
                $product->is_deleted = 0;
                $product->save();
            } 
            
            else {
                return response()->json(['message' => 'Invalid delete type'], 400);
            }
        }

        event(new ProductEvent( 'delete'));
        event(new AllocationEvent( 'delete'));
        event(new LogEvent( 'delete'));
        event(new InventoryEvent( 'delete'));

        return response()->json(['message' => 'Products deleted']);
    }
    public function delProductTagMaster(Request $request){
        $ids = $request->input('ids');
        $type = $request->input('type');

        if (!is_array($ids) || empty($ids)) {
            return response()->json(['message' => 'No product IDs provided'], 400);
        }

        foreach ($ids as $id) {
            $product = Product_tagging::find($id);
            if (!$product) continue;

            if ($type === 'soft') {

                $globalController = new GlobalController();
                $globalController->logAction(
                    'Products Tagging', 'm_product_tagging_master',
                    'delete',
                    'Product Code : ' . $product->product_code
                );

                $product->is_deleted = 1;
                $product->save();
            } elseif ($type === 'hard') {
                $globalController = new GlobalController();
                $globalController->logAction(
                    'Products Tagging', 'm_product_tagging_master',
                    'delete',
                    'Product Code : ' . $product->product_code
                );
                $product->delete();
            } else {
                return response()->json(['message' => 'Invalid delete type'], 400);
            }
        }

        return response()->json(['message' => 'Products deleted']);
    }
    public function delProductTagDetail(Request $request){
        $ids = $request->input('ids');
        $type = $request->input('type');

        if (!is_array($ids) || empty($ids)) {
            return response()->json(['message' => 'No product IDs provided'], 400);
        }

        foreach ($ids as $id) {
            $productTag = Product_tagging_details::find($id);
            $product_code = Products::find($productTag->product_id)->product_code;
            if (!$productTag) continue;

            if ($type === 'soft') {

                $globalController = new GlobalController();
                $globalController->logAction(
                    'Products Tagging', 'm_product_tagging_detail',
                    'delete',
                    'Product Code : ' . $product_code
                );

                $productTag->is_deleted = 1;
                $productTag->save();
            } elseif ($type === 'hard') {
                $globalController = new GlobalController();
                $globalController->logAction(
                    'Products Tagging', 'm_product_tagging_detail',
                    'delete',
                    'Product Code : ' . $product_code
                );
                $productTag->delete();
            } else {
                return response()->json(['message' => 'Invalid delete type'], 400);
            }
        }

        return response()->json(['message' => 'Products deleted']);
    }
    public function delPrice($id){
        $productPrice = Price_setup::findOrFail($id);
        $productPrice->forceDelete(); // ✅ Soft delete: sets deleted_at

        $product_code = Products::find($productPrice->product_id)->product_code;
        $customer_group = Customer_group::find($productPrice->customer_group_id)->customer_group_en;
        
        $globalController = new GlobalController();
        $globalController->logAction(
            'Products Pricing', 'm_price_setup',
            'delete',
            'Product Code : ' . $product_code . ' | Customer Group : ' . $customer_group,
        );

        return response()->json(['message' => 'Price deleted']);
    }
    public function getProductInfo($id){
        $product = Products::with(['genres','images', 'supplier'])
            ->where('id', $id)
            ->where('is_deleted', 0)
            ->first();

        // ✅ Stop early if no product found
        if (!$product) {
            return response()->json([
                'success' => true,
                'message' => 'Product is empty',
                'product' => [
                    'genres' => [],
                    'images' => [],
                    'supplier_code' => '',
                ],
            ]);
        }


        // Map genres with 'en' and 'cn'
        $mappedGenres = $product->genres->map(function ($genre) {
            return [
                'value' => $genre->id,
                'en' => $genre->genre_en,
                'cn' => $genre->genre_cn,
            ];
        });

        // Map images path and type
        $mappedImages = $product->images->map(function ($image) {
            return [
                'id' => $image->id,
                'type' => $image->type,
                'path' => Storage::url($image->path),
                'rank' => $image->rank,
            ];
        });

        // Convert product to array and add genres as a separate key
        $productData = $product->toArray();
        $productData['genres'] = $mappedGenres;
        $productData['images'] = $mappedImages;
        $productData['supplier_code'] = optional($product->supplier)->supplier_code; // add this line

        return response()->json([
            'success' => true,
            'message' => 'success',
            'product' => $productData,
        ]);
    }
    public function getRetailPricing($product_id){
        $priceSetup = Price_setup::with('customerGroup')
        ->where('product_id', $product_id)
        ->where('type', 'retail')
        ->orderBy('id','desc')
        ->get();

        if (!$priceSetup) {
            return response()->json([
                'success' => false,
                'message' => 'Product not found',
            ], 404); // Use proper HTTP status code for "Not Found"
        }

        return response()->json([
            'success' => true,
            'message' => 'Success',
            'data' => $priceSetup->toArray(),
        ]);
    }
    public function getWholesalePricing($product_id){
        $priceSetup = Price_setup::with('customerGroup')
            ->where('product_id', $product_id)
            ->where('type', 'wholesale')
            ->orderBy('id','desc')
            ->get();

        if (!$priceSetup) {
            return response()->json([
                'success' => false,
                'message' => 'Product not found',
            ], 404); // Use proper HTTP status code for "Not Found"
        }

        return response()->json([
            'success' => true,
            'message' => 'Success',
            'data' => $priceSetup->toArray(),
        ]);
    }
    public function getPrductPricingById($id){
        $priceSetup = Price_setup::with('customerGroup')
            ->where('id', $id)
            ->orderBy('id','desc')
            ->first();

        if (!$priceSetup) {
            return response()->json([
                'success' => false,
                'message' => 'Product not found',
            ], 404); // Use proper HTTP status code for "Not Found"
        }

        return response()->json([
            'success' => true,
            'message' => 'Success',
            'data' => $priceSetup,
        ]);
    }
    public function getPrductPricingGroupId($id){
        $priceSetup = Price_setup::with('customerGroup')
            ->where('customer_group_id', $id)
            ->orderBy('id','desc')
            ->first();

        if (!$priceSetup) {
            return response()->json([
                'success' => false,
                'message' => 'Product not found',
            ], 404); // Use proper HTTP status code for "Not Found"
        }

        return response()->json([
            'success' => true,
            'message' => 'Success',
            'data' => $priceSetup,
        ]);
    }
    public function getProductImages($product_id){
        $productImages = Product_images::select('id', 'type', 'path', 'rank')
            ->where('product_id', $product_id)
            ->orderBy('id', 'asc')
            ->get();

        if ($productImages->isEmpty()) {
            return response()->json([
                'success' => true, // Return success but with empty data
                'message' => 'No images found for this product',
                'data' => [],
            ]);
        }

        // Transform paths to full URLs
        $productImages->transform(function ($image) {
            $image->path = Storage::url($image->path);
            return $image;
        });

        return response()->json([
            'success' => true,
            'message' => 'Success',
            'data' => $productImages->toArray(),
        ]);
    }
    public function getProductImagesTag($id){
        $productImages = Product_images_tagging::select('id', 'type', 'path', 'rank')
            ->where('product_id', $id)
            ->orderBy('id', 'asc')
            ->get();

        if ($productImages->isEmpty()) {
            return response()->json([
                'success' => true, // Return success but with empty data
                'message' => 'No images found for this product',
                'data' => [],
            ]);
        }

        // Transform paths to full URLs
        $productImages->transform(function ($image) {
            $image->path = Storage::url($image->path);
            return $image;
        });

        return response()->json([
            'success' => true,
            'message' => 'Success',
            'data' => $productImages->toArray(),
        ]);
    }
    public function updateTntWholesale(Request $request, $id){
        $product = Products::find($id);
        if (!$product) {
            return response()->json(['message' => 'Product not found'], 404);
        }

        $validated = $request->validate([
            'newValue' => 'required|boolean',
            'type' => 'required|string|in:is_tnt,is_wholesale',
        ]);

        switch ($validated['type']) {
            case 'is_tnt':
                $product->is_tnt = $validated['newValue'];

                $Status = ($validated['newValue'] === 0 ? 'Deactivate' : 'Activate');
                $globalController = new GlobalController();
                $globalController->logAction(
                    'Products', 'm_products',
                    'update',
                    $Status . ' TNT : ' . $product->product_code
                );
            break;
            case 'is_wholesale':
                $product->is_wholesale = $validated['newValue'];

                $Status = ($validated['newValue'] === 0 ? 'Deactivate' : 'Activate');
                $globalController = new GlobalController();
                $globalController->logAction(
                    'Products', 'm_products',
                    'update',
                    $Status . ' Wholesale : ' . $product->product_code
                );
            break;
        }
        $product->save();

        event(new ProductEvent( 'update'));
        event(new LogEvent( 'update'));
        event(new InventoryEvent( 'update'));
        event(new AllocationEvent( 'update'));

        return response()->json(['message' => 'is_tnt updated successfully']);
    }
    public function updateProduct(Request $request, $id){
        $OrigID = $id;
        // If product ID is 0, create a new product
        if ((int) $id === 0) {
            // Prepare product data including status
            $productData = $request->only([
                'product_code', 
                'old_product_code',
                'product_title_en', 
                'product_title_cn', 
                'product_description_en',
                'product_description_cn', 
                'product_specs_en', 
                'product_specs_cn', 
                'barcode',
                'pcs_per_carton', 
                'item_weight', 
                'inventry_qty', 
                'preorder_start_date',
                'preorder_end_date', 
                'release_date', 
                'po_dateline', 
                'preorder_dateline',
                'product_type_id',
                'manufacturer_id',
                'series_id',
                'brand_id',
                'supplier_id',
                'supplier_currency',
                'offered_cost',
                'item_cost_currency',
                'item_cost',
                'shipping_currency',
                'shipping_cost',
                'rwarehouse',
                'is_tnt',
                'is_wholesale',
                'is_active_banner',
                'created_date',
                'is_import'
            ]);
            // Create product with status
            $product = Products::create($productData);
            $id = $product->id; // update ID for image handling later
        } else {
            // Otherwise, find existing product
            $product = Products::find($id);
            $orig_item_cost = $product->item_cost;
            $new_item_cost = $request->item_cost;

            if( $new_item_cost <> $orig_item_cost){
                $this->updateOrderCalculation($id);
            }

            if (!$product) {
                return response()->json(['message' => 'Product not found'], 404);
            }

            // Prepare update data including the new status
            $updateData = $request->only([
                'product_code', 
                'old_product_code',
                'product_title_en', 
                'product_title_cn', 
                'product_description_en',
                'product_description_cn', 
                'product_specs_en', 
                'product_specs_cn', 
                'barcode',
                'pcs_per_carton', 
                'item_weight', 
                'inventry_qty', 
                'preorder_start_date',
                'preorder_end_date', 
                'release_date', 
                'po_dateline', 
                'preorder_dateline',
                'product_type_id',
                'manufacturer_id',
                'series_id',
                'brand_id',
                'supplier_id',
                'supplier_currency',
                'offered_cost',
                'item_cost_currency',
                'item_cost',
                'shipping_currency',
                'shipping_cost',
                'rwarehouse',
                'is_tnt',
                'is_wholesale',
                'is_active_banner',
                'created_date',
                'is_import'
            ]);
            $product->update($updateData);
        }
        // Copy PRICING from another product
        if ($request->is_new_product_id && $request->is_new_product_id > 0) {
            $originalProductId = $request->is_new_product_id;
            if ($request->is_copy_price_wc === 'true') {
                $wholesalePrices = Price_setup::where('product_id', $originalProductId)
                    ->where('type', 'wholesale')
                    ->get();

                foreach ($wholesalePrices as $price) {
                    Price_setup::create([
                        'product_id'           => $id,
                        'customer_group_id'    => $price->customer_group_id,
                        'type'                 => $price->type,
                        'currency'             => $price->currency,
                        'pcs_or_crtn'          => $price->pcs_or_crtn,
                        'deposit'              => $price->deposit,
                        'price_a'              => $price->price_a,
                        'price_b'              => $price->price_b,
                        'price_c'              => $price->price_c,
                        'retail_price'         => $price->retail_price,
                        'preorder_price'       => $price->preorder_price,
                        'profit_prcnt_a'       => $price->profit_prcnt_a,
                        'profit_prcnt_b'       => $price->profit_prcnt_b,
                        'profit_prcnt_c'       => $price->profit_prcnt_c,
                        'price_a_pcs_crtn'     => $price->price_a_pcs_crtn,
                        'price_b_pcs_crtn'     => $price->price_b_pcs_crtn,
                        'price_c_pcs_crtn'     => $price->price_c_pcs_crtn,
                        'price_b_to_pcs_crtn'  => $price->price_b_to_pcs_crtn,
                        'price_c_to_pcs_crtn'  => $price->price_c_to_pcs_crtn,
                    ]);
                }
            }

            if ($request->is_copy_price_rc === 'true') {
                $retailPrices = Price_setup::where('product_id', $originalProductId)
                    ->where('type', 'retail')
                    ->get();

                foreach ($retailPrices as $price) {
                    Price_setup::create([
                        'product_id'           => $id,
                        'customer_group_id'    => $price->customer_group_id,
                        'type'                 => $price->type,
                        'currency'             => $price->currency,
                        'pcs_or_crtn'          => $price->pcs_or_crtn,
                        'deposit'              => $price->deposit,
                        'price_a'              => $price->price_a,
                        'price_b'              => $price->price_b,
                        'price_c'              => $price->price_c,
                        'retail_price'         => $price->retail_price,
                        'preorder_price'       => $price->preorder_price,
                        'profit_prcnt_a'       => $price->profit_prcnt_a,
                        'profit_prcnt_b'       => $price->profit_prcnt_b,
                        'profit_prcnt_c'       => $price->profit_prcnt_c,
                        'price_a_pcs_crtn'     => $price->price_a_pcs_crtn,
                        'price_b_pcs_crtn'     => $price->price_b_pcs_crtn,
                        'price_c_pcs_crtn'     => $price->price_c_pcs_crtn,
                        'price_b_to_pcs_crtn'  => $price->price_b_to_pcs_crtn,
                        'price_c_to_pcs_crtn'  => $price->price_c_to_pcs_crtn,
                    ]);
                }
            }

            if ($request->is_copy_media === 'true') {
                $originalProductId = $request->is_new_product_id;

                $media = Product_images::where('product_id', $originalProductId)->get();

                foreach ($media as $img) {
                    // Extract filename
                    $pathParts = pathinfo($img->path);
                    $originalFilename = $pathParts['basename'];
                    $extension = $pathParts['extension'];

                    // Replace product code in the filename
                    $oldProductCode = $request->old_product_code; // this is the original code
                    $newProductCode = $request->product_code;

                    // Build new filename
                    $newFilename = str_replace($oldProductCode, $newProductCode, $originalFilename);
                    $newPath = str_replace($originalFilename, $newFilename, $img->path);

                    // Copy file on disk (if needed)
                    if (\Storage::disk('public')->exists($img->path)) {
                        \Storage::disk('public')->copy($img->path, $newPath);
                    }

                    // Save new DB record for the new product
                    Product_images::create([
                        'product_id' => $id,
                        'type'       => $img->type,
                        'path'       => $newPath,
                        'rank'       => $img->rank,
                    ]);
                }
            }
        }

        $this->updateProductRemQty($id);

        $ProductStatusService = new ProductStatusService();
        $ProductStatus = $ProductStatusService->getProductStatus($id);
        Products::where('id', $id)->update([
            'product_status' => $ProductStatus
        ]);

        // Sync genres if provided
        if ($request->has('genres')) {
            $product->genres()->sync($request->genres);
        }

        // Update images if provided
        if ($request->has('image_data')) {
            $newImageFiles = $request->file('images', []);
            $newImageIndex = 0;

            foreach ($request->image_data as $imageDataJson) {
                $image = json_decode($imageDataJson, true);

                if (!empty($image['isDeleted']) && isset($image['id'])) {
                    Product_images::destroy($image['id']);
                } elseif (!empty($image['isNew'])) {
                    if (isset($newImageFiles[$newImageIndex])) {
                        $file = $newImageFiles[$newImageIndex];
                        $productCode = $request->input('product_code');
                        $extension = $file->getClientOriginalExtension();
                        $type = $image['type'];
                        $filename = '';
                        $directory = '';

                        switch ($type) {
                            case 'thumbnail':
                                $filename = "{$productCode}_thumbnail.webp";
                                $directory = 'products/thumbnail';
                                break;
                            case 'display':
                                $filename = "{$productCode}_display.webp";
                                $directory = 'products/display';
                                break;
                            case 'banner':
                                $filename = "{$productCode}_banner.webp";
                                $directory = 'products/banner';
                                break;
                            case 'slide':
                                $timestamp = str_replace('.', '', microtime(true)) . "_{$newImageIndex}";
                                $filename = "{$productCode}_{$timestamp}.jpg";
                                $directory = 'products/slide';
                                break;
                        }

                        if ($filename && $directory) {
                            $path = $file->storeAs($directory, $filename, 'public');

                            Product_images::create([
                                'product_id' => $id,
                                'type' => $type,
                                'path' => $path,
                                'rank' => $image['rank'],
                            ]);
                        }
                        $newImageIndex++;
                    }
                } elseif (!empty($image['id'])) {
                    Product_images::find($image['id'])->update(['rank' => $image['rank']]);
                }
            }
        }

        $Action = ($OrigID === 0 ? 'insert' : 'update');

        $globalController = new GlobalController();
        $globalController->logAction(
            'Products', 'm_products',
            $Action,
            'Product Code : ' . $request->product_code
        );

        event(new ProductEvent( $Action));
        event(new LogEvent( $Action));
        event(new InventoryEvent( $Action));
        event(new AllocationEvent( $Action));

        return response()->json([
            'message' => 'Product updated successfully',
            'product_status' => $ProductStatus,
            'id'      => $id,
            'action'  => $Action
        ]);
    }
    public function updateProductTag(Request $request, $id){
        $OrigID = $id;
        // If product ID is 0, create a new product
        if ((int) $id === 0) {
            // Prepare product data including status
            $productData = $request->only([
                'product_code', 
                'old_product_code',
                'product_title_en', 
                'product_title_cn', 
                'product_description_en',
                'product_description_cn', 
                'product_specs_en', 
                'product_specs_cn', 
                'is_tnt',
                'is_activate_banner',
            ]);
            // Create product with status
            $product = Product_tagging::create($productData);
            $id = $product->id; // update ID for image handling later
        } else {
            // Otherwise, find existing product
            $product = Product_tagging::find($id);
            if (!$product) {
                return response()->json(['message' => 'Product not found'], 404);
            }
            // Prepare update data including the new status
            $updateData = $request->only([
                'product_code', 
                'old_product_code',
                'product_title_en', 
                'product_title_cn', 
                'product_description_en',
                'product_description_cn', 
                'product_specs_en', 
                'product_specs_cn', 
                'is_tnt',
                'is_activate_banner',
            ]);
            $product->update($updateData);
        }
        // Update images if provided
        if ($request->has('image_data')) {
            $newImageFiles = $request->file('images', []);
            $newImageIndex = 0;

            foreach ($request->image_data as $imageDataJson) {
                $image = json_decode($imageDataJson, true);

                if (!empty($image['isDeleted']) && isset($image['id'])) {
                    Product_images_tagging::destroy($image['id']);
                } elseif (!empty($image['isNew'])) {
                    if (isset($newImageFiles[$newImageIndex])) {
                        $file = $newImageFiles[$newImageIndex];
                        $productCode = $request->input('product_code');
                        $extension = $file->getClientOriginalExtension();
                        $type = $image['type'];
                        $filename = '';
                        $directory = '';

                        switch ($type) {
                            case 'thumbnail':
                                $filename = "{$productCode}_thumbnail.webp";
                                $directory = 'products/thumbnail';
                                break;
                            case 'display':
                                $filename = "{$productCode}_display.webp";
                                $directory = 'products/display';
                                break;
                            case 'banner':
                                $filename = "{$productCode}_banner.webp";
                                $directory = 'products/banner';
                                break;
                            case 'slide':
                                $timestamp = str_replace('.', '', microtime(true)) . "_{$newImageIndex}";
                                $filename = "{$productCode}_{$timestamp}.{$extension}";
                                $directory = 'products/slide';
                                break;
                        }

                        if ($filename && $directory) {
                            $path = $file->storeAs($directory, $filename, 'public');

                            Product_images_tagging::create([
                                'product_id' => $id,
                                'type' => $type,
                                'path' => $path,
                                'rank' => $image['rank'],
                            ]);
                        }
                        $newImageIndex++;
                    }
                } elseif (!empty($image['id'])) {
                    Product_images_tagging::find($image['id'])->update(['rank' => $image['rank']]);
                }
            }
        }

        $globalController = new GlobalController();
        $globalController->logAction(
            'Products Tagging', 'm_product_tagging_master',
            'update',
            'Product Code : ' . $request->product_code
        );

        return response()->json([
            'message' => 'Product tag updated successfully',
            'id'      => $id,
            'action'  => $OrigID === 0 ? 'insert' : 'update'
        ]);
    }
    public function insertProductTag($id, Request $request)  {
        // Step 1: Extract product data from the request
        $productData = $request->only([
            'product_code', 
            'old_product_code',
            'product_title_en', 
            'product_title_cn', 
            'is_tnt',
            'is_wholesale',
        ]);

        // Step 2: Create the product tag entry
        $product = Product_tagging::create($productData);
        $MasterId = $product->id; // Save the ID of the newly created product for later use

        // Step 3: Get the product IDs passed in the request (assume they are in a string like '1825,1824')
        $productIdsString = $id;

        // Step 4: Convert the string into an array of product IDs
        $productIds = array_map('intval', explode(',', $productIdsString));

        // Step 5: Loop through each product ID and prepare the data to insert into `m_product_tagging_detail`
        $productTaggingDetails = [];
        foreach ($productIds as $productId) {
            $productTaggingDetails[] = [
                'product_tagging_master_id' => $MasterId,
                'product_id' => $productId,
            ];
        }

        // Step 6: Insert the details into the `m_product_tagging_detail` table
        DB::table('m_product_tagging_detail')->insert($productTaggingDetails);

        $globalController = new GlobalController();
        $globalController->logAction(
            'Products Tagging', 'm_product_tagging_master',
            'insert',
            'Product Code : ' . $request->product_code
        );

        // Step 7: Return success response
        return response()->json([
            'message' => 'Product tag inserted successfully',
            'id' => $MasterId,  // Return the master ID that was just created
            'action' => $id === 0 ? 'insert' : 'update'
        ]);
    }
    public function insertProductTagNew($masterId, Request $request){

        $productIds = $request->input('product_ids');

        // Find any product_ids that already exist for this master ID
        $existingProductIds = Product_tagging_details::where('product_tagging_master_id', $masterId)
            ->whereIn('product_id', $productIds)
            ->pluck('product_id')
            ->toArray();

        if (!empty($existingProductIds)) {
            return response()->json([
                'success' => false,
                'message' => 'Some product IDs already exist for this tag.',
                'existing_product_ids' => $existingProductIds,
            ]); // 422 Unprocessable Entity - validation type error
        }

        $now = now();
        $productTaggingDetails = [];
        foreach ($productIds as $productId) {
            $productTaggingDetails[] = [
                'product_tagging_master_id' => $masterId,
                'product_id' => $productId,
                'created_at' => $now,
                'updated_at' => $now,
            ];

            $product_code = Products::find($productId)->product_code;

            $globalController = new GlobalController();
            $globalController->logAction(
                'Products Tagging', 'm_product_tagging_detail',
                'insert',
                'Product Code : ' . $product_code
            );
        }

        Product_tagging_details::insert($productTaggingDetails);

        return response()->json([
            'success' => true,
            'message' => 'Product tag details inserted successfully',
            'master_id' => $masterId,
        ]);
    }
    public function upsertPricing(Request $request){
        $data = $request->all();

        // Extract condition keys
        $condition = [
            'product_id' => $data['product_id'],
            'customer_group_id' => $data['customer_group_id'],
            'type' => $data['type']
        ];

        // Remove condition keys from update data
        $updateData = array_diff_key($data, $condition);

        Price_setup::updateOrCreate($condition, $updateData);


        $product_code = Products::find($data['product_id'])->product_code;
        $customer_group = Customer_group::find($data['customer_group_id'])->customer_group_en;
        
        $globalController = new GlobalController();
        $globalController->logAction(
            'Products Pricing', 'm_price_setup',
            'update',
            'Product Code : ' . $product_code . ' | Customer Group : ' . $customer_group,
        );


        return response()->json(['message' => 'Pricing updated successfully']);
    }
    public function updateProductImageRank(Request $request){
        $validated = $request->validate([
            'updates' => 'required|array',
            'updates.*.id' => 'required|integer|exists:m_product_images,id',
            'updates.*.rank' => 'required|integer',
        ]);

        foreach ($validated['updates'] as $update) {
            Product_images::where('id', $update['id'])->update(['rank' => $update['rank']]);
        }

        return response()->json(['message' => 'Image ranks updated successfully']);
    }
    public function getProductExist($productCode){
        return Products::where('product_code', $productCode)->count();
    }
    public function getProductExistTag($productCode){
        return Product_tagging::where('product_code', $productCode)->count();
    }
    public function updateOrderCalculation(int $product_id){
        $baseCurrency = ISSettings::where('tag', 'basecurrency')->value('en');

        $orders = Orders::where('product_id', $product_id)->get();

        foreach ($orders as $order) {
            $customerCurrency = $order->currency;
            $exchangeRate = $order->ex_rate ?? 1;
            $qty = $order->qty;
            $price = $order->price;

            $conversionKey = $customerCurrency . $baseCurrency;

            $operator = DB::table('m_operator')
                ->where('convertion', $conversionKey)
                ->value('operator');

            $itemCost = Products::where('product_id', $product_id)->value('item_cost') ?? 0;

            $estimatedCost = $qty * $itemCost;

            if ($exchangeRate == 1) {
                $totalSales = $qty * $price;
                $profit = $totalSales - $estimatedCost;
            } else {
                if ($operator === 'Divide') {
                    $totalSales = ($qty * $price) / $exchangeRate;
                    $profit = ($totalSales - $estimatedCost) / $exchangeRate;
                } else { // Multiply
                    $totalSales = ($qty * $price) * $exchangeRate;
                    $profit = ($totalSales - $estimatedCost) * $exchangeRate;
                }
            }

            // Update the order
            $order->e_total_sales = $totalSales;
            $order->e_profit = $profit;
            $order->e_cost_total = $estimatedCost;
            $order->save();
        }
    }
    function updateProductRemQty(int $product_id){
        // Step 1: Get the product
        $product = Products::where('id', $product_id)->first();

        if (!$product) {
            throw new \Exception("Product not found: {$product_id}");
        }

        // Step 2: Get needed values
        $orderQty = Orders::where('product_id', $product_id)->sum('Qty');

        $poQty = POrder_detail::where('product_id', $product_id)
            ->whereIn('postatus_id', [1, 2])
            ->sum('Qty');

        $remPOQty = POrder_detail::where('product_id', $product_id)
            ->whereIn('postatus_id', [1, 2])
            ->get()
            ->sum(fn ($row) => ($row->qty ?? 0) - ($row->receive_qty ?? 0));

        // Step 3: Determine values to update
        $status = $product->product_status;
        $remQty = 0;
        $isPOQty = 0;

        switch ($status) {
            case 'Pre-order':
                $remQty = $orderQty;
                $isPOQty = 0;
                break;

            case 'Coming Soon':
                if ($poQty > 0) {
                    $remQty = $poQty;
                    $isPOQty = 1;
                } else {
                    $remQty = $orderQty;
                    $isPOQty = 0;
                }
                break;

            case 'Partial Received':
                $remQty = $remPOQty;
                $isPOQty = 0;
                break;

            case 'No Order':
                $remQty = $poQty;
                $isPOQty = 0;
                break;

            case 'Sold Out':
                $remQty = 0;
                $isPOQty = 0;
                break;
        }

        // Step 4: Update product
        $product->rem_qty = $remQty;
        $product->is_po_qty = $isPOQty;
        $product->save();
    }
    public function getProfitabilityByOrders(int $productId){
        $perPage = request('per_page', 10); // Allow dynamic per-page

        $paginator = Orders::with(['customer', 'product'])
            ->where('product_id', $productId)
            ->where('show_category', 'orders')
            ->orderByDesc('id')
            ->paginate($perPage); // Laravel handles page from query string (?page=2)

        // Transform the results
        $data = $paginator->getCollection()->map(function ($order) {
            return [
                'ID' => $order->id,
                'product_status' => 'Preorder',
                'customer_code' => $order->customer?->customer_code ?? '',
                'currency' => $order->currency ?? '',
                'customer_name' => $order->customer?->account_name_en ?? '',
                'invoice_no' => $order->invoice_no ?? '',
                'product_code' => $order->product?->product_code ?? '',
                'qty' => $order->qty,
                'item_cost' => number_format($order->product?->item_cost ?? 0, 2),
                'total_cost' => number_format($order->e_cost_total, 2),
                'price' => number_format($order->price, 2),
                'total_price' => number_format($order->e_total_sales, 2),
                'profit' => number_format($order->e_profit, 2),
            ];
        });

        // Replace the collection with the transformed one
        $paginator->setCollection($data);

        return response()->json([
            'success' => true,
            'message' => 'success',
            'data' => $paginator->items(),
            'pagination' => [
                'current_page' => $paginator->currentPage(),
                'per_page' => $paginator->perPage(),
                'total' => $paginator->total(),
                'last_page' => $paginator->lastPage(),
                'list' => 'order'
            ]
        ]);
    }
    public function getProfitabilityByInvoice(int $productId){

        $perPage = 10; // default 10 per page
        $paginator = Invoice_detail::with(['customer', 'product'])
            ->where('product_id', $productId)
            ->orderByDesc('id')
            ->paginate($perPage);

        $data = $paginator->getCollection()->map(function ($item) {
            $itemCost = $item->product->item_cost ?? 0;
            $qty = $item->qty ?? 0;
            $price = $item->price ?? 0;
            $exRate = $item->ex_rate ?? 1;

            $totalCost = $itemCost * $qty;
            $priceConverted = $price * $exRate;
            $totalPrice = $priceConverted * $qty;
            $profit = $totalPrice - $totalCost;

            return [
                'ID' => $item->id,
                'customer_code' => $item->customer->customer_code ?? '',
                'product_status' => 'Preorder',
                'currency' => $item->currency ?? '',
                'customer_name' => $item->customer->account_name_en ?? '',
                'invoice_no' => $item->invoice_no ?? '',
                'product_code' => $item->product->product_code ?? '',
                'qty' => $qty,
                'item_cost' => number_format($itemCost,2),
                'total_cost' => number_format($totalCost,2),
                'price' => number_format($priceConverted,2),
                'total_price' => number_format($totalPrice,2),
                'profit' => number_format($profit,2),
            ];
        });

        // Replace the paginator's collection with the transformed data
        $paginator->setCollection($data);


        return response()->json([
            'success' => true,
            'message' => 'success',
            'data' => $paginator->items(),
            'pagination' => [
                'current_page' => $paginator->currentPage(),
                'per_page' => $paginator->perPage(),
                'total' => $paginator->total(),
                'last_page' => $paginator->lastPage(),
                'list' => 'order'
            ]
        ]);
    }
    public function delDrodpdown(Request $request){
        $id = $request->input('id');
        $type = $request->input('type');

        // Map type strings to their models
        $modelMap = [
            'ProductType' => Product_type::class,
            'Manufacturer' => Manufacturer::class,
            'Series' => Series::class,
            'Brand' => Brands::class,
            'Genre' => Genre::class,
        ];

        if (!isset($modelMap[$type])) {
            return response()->json(['message' => 'Invalid type'], 400);
        }

        $modelClass = $modelMap[$type];

        try {
            $record = $modelClass::findOrFail($id);
            $record->delete();  // or ->forceDelete() if you want hard delete
        } catch (\Exception $e) {
            return response()->json(['message' => 'Record not found or deletion failed'], 404);
        }

        return response()->json(['message' => $type . ' deleted']);
    }
    public function updateDropdowns(Request $request, $id){
        $type = $request->input('type');
        $en = $request->input('en');
        $cn = $request->input('cn');
        $value2 = $request->input('value2');

        $id = (int) $id;  // Casts $id to an integer

        if ($type === 'ProductType') {
            if ($id === null || $id === 0) {
                $Product_type = Product_type::create([
                    'product_type_en' => $en,
                    'product_type_cn' => $cn,
                    'is_deleted' => 0,
                ]);
                $id = $Product_type->id; // update ID for image handling later
            }
            else{
                $Product_type = Product_type::where('id', $id)->first();
                $Product_type->product_type_en = $en;
                $Product_type->product_type_cn = $cn;
                $Product_type->save();
            }
        }

        if ($type === 'Manufacturer') {
            if ($id === null || $id === 0) {
                Manufacturer::create([
                    'manufacturer_en' => $en,
                    'manufacturer_cn' => $cn,
                    'is_deleted' => 0,
                ]);
            }
            else{
                $Manufacturer = Manufacturer::where('id', $id)->first();
                $Manufacturer->manufacturer_en = $en;
                $Manufacturer->manufacturer_cn = $cn;
                $Manufacturer->save();
            }
        }

        if ($type === 'Series') {
            if ($id === null || $id === 0) {
                Series::create([
                    'series_en' => $en,
                    'series_cn' => $cn,
                    'manufacturer_id' => $value2,
                    'is_deleted' => 0,
                ]);
            }
            else{
                $Series = Series::where('id', $id)->first();
                $Series->series_en = $en;
                $Series->series_cn = $cn;
                $Series->manufacturer_id = $value2;
                $Series->save();
            }
        }

        if ($type === 'Brand') {
            if ($id === null || $id === 0) {
                Brands::create([
                    'brands_en' => $en,
                    'brands_cn' => $cn,
                    'is_deleted' => 0,
                ]);
            }
            else{
                $Brands = Brands::where('id', $id)->first();
                $Brands->brands_en = $en;
                $Brands->brands_cn = $cn;
                $Brands->save();
            }
        }

        if ($type === 'Genre') {
            if ($id === null || $id === 0) {
                Genre::create([
                    'genre_en' => $en,
                    'genre_cn' => $cn,
                    'is_deleted' => 0,
                ]);
            }
            else{
                $Brands = Genre::where('id', $id)->first();
                $Brands->genre_en = $en;
                $Brands->genre_cn = $cn;
                $Brands->save();
            }
        }

        return response()->json([
            'message' => $type . ' updated successfully',
            'id' => $id,
            'action' => $id === 0 ? 'insert' : 'update'
        ]);
    }
    function getManufacturerIdBySeries($id){
        $manufacturerId = Series::where('id', $id)->value('manufacturer_id');

        return $manufacturerId;
    }
    public function getPreorderProducts(Request $request){
        $perPage = (int) $request->input('per_page', 10);
        $search = $request->input('search', '');

        $query = Products::with(['images']) // removed 'priceSetup' here
            ->where('is_deleted', 0)  // only non-deleted products
            ->where('product_status', 'Pre-order')  // only preorder products
            ->orderBy('id', 'desc');

        if ($search) {
            $query->where(function ($q) use ($search) {
                $q->where('product_code', 'like', "%{$search}%")
                ->orWhere('product_title_en', 'like', "%{$search}%")
                ->orWhere('product_title_cn', 'like', "%{$search}%")
                ->orWhere('product_status', 'like', "%{$search}%")
                ->orWhere('rwarehouse', 'like', "%{$search}%");
            });
        }

        $result = $perPage === -1 ? $query->get() : $query->paginate($perPage);

        $transform = function ($product): mixed {
            // Removed priceSetup-related fields here
            $product->product_thumbnail = optional(value: $product->images->firstWhere('type', 'thumbnail'))->path;
            return $product;
        };

        $data = $perPage === -1
            ? $result->map($transform)
            : tap($result)->getCollection()->transform($transform);

        return response()->json([
            'success' => true,
            'message' => 'success',
            'product' => $perPage === -1
                ? [
                    'current_page' => 1,
                    'data' => $data,
                    'last_page' => 1,
                    'per_page' => $data->count(),
                    'total' => $data->count(),
                ]
                : $result,
        ]);
    }
    function updateProductStatusById($product_id){
        $ProductStatusService = new ProductStatusService();
        $ProductStatus = $ProductStatusService->getProductStatus($product_id);

        // Update product_status column for the given product ID
        $updated = Products::where('id', $product_id)->update([
            'product_status' => $ProductStatus
        ]);

        return $updated; // returns number of affected rows (1 if success)
    }
    function updateAllProductStatus(){
        $products = Products::all();

        foreach ($products as $product) {
            $result = $this->updateProductStatusById($product->id);

            if ($result) {
                echo $product->product_code . " Successfully Updated<br>";
            } else {
                echo $product->product_code . " Update Failed<br>";
            }
        }
    }
    public function getTracking($itemCode, $warehouse, $language){
        
        $this->language = $language;
        $resultArray = [];

        // 1. GRN Details
        $grnDetails = $this->getGrnDetails($itemCode, $warehouse, $resultArray);
        // return $grnDetails;
        // 2. Internal Transfer Incoming (Headers)
        $this->getInternalTransferIncomingHeaders($itemCode, $warehouse, $resultArray);

        // 3. Internal Transfer Incoming (Details)
        $this->getInternalTransferIncomingDetails($itemCode, $warehouse, $resultArray);

        // 4. Internal Transfer Outgoing (From Warehouse)
        $this->getInternalTransferOutgoingHeaders($itemCode, $warehouse, $resultArray);
        $this->getInternalTransferOutgoingDetails($itemCode, $warehouse, $resultArray);

        // 5. Internal Transfer Incoming (To Warehouse)
        $this->getInternalTransferToWarehouseHeaders($itemCode, $warehouse, $resultArray);
        $this->getInternalTransferToWarehouseDetails($itemCode, $warehouse, $resultArray);

        // 6. Inventory Withdrawal
        $this->getInventoryWithdrawalHeaders($itemCode, $warehouse, $resultArray);
        $this->getInventoryWithdrawalDetails($itemCode, $warehouse, $resultArray);

        // Sort and remove duplicates
        $resultArray = $this->sortAndDeduplicate($resultArray);
    
        $unshippedQty = $this->getUnshippedQty($itemCode, $warehouse);
        $remQty = $this->getRemainingQty($itemCode, $warehouse);

        return response()->json([
            'list' => $resultArray,
            'unshippedQty' => $unshippedQty,
            'remQty' => $remQty,
        ]);
    }
    public function getUnshippedQty($productCode, $warehouse){
        $shipoutGroups = Shipout_items::with('product')
            ->where('status', 1)
            ->whereHas('product', function ($query) use ($productCode) {
                $query->where('product_code', $productCode);
            })->get();

        return $shipoutGroups->sum('qty');
    }
    public function getRemainingQty($productCode, $warehouse){
        $inventory = Inventory_tblmaster::whereHas('product', function ($query) use ($productCode) {
                $query->where('product_code', $productCode);
            })
            ->where('warehouse', $warehouse)
            ->first();

        if (!$inventory) {
            return 0;
        }

        return $inventory->qty - $inventory->allocated_qty;
    }
    protected function getGrnDetails($itemCode, $warehouse, &$resultArray){
        $grnDetails = Grn_details::with(['product', 'whList'])
            ->whereHas('product', function ($query) use ($itemCode) {
                $query->where('product_code', $itemCode);
            })
            ->get()
            ->sortByDesc(function ($grn) {
                return Carbon::parse($grn->grn_date)->format('Ymd');
            });


        foreach ($grnDetails as $grn) {
            $warehouseName = $this->getWarehouseName($grn->whList);
            $dateNumber = Carbon::parse($grn->grn_date)->format('Ymd');

            if ($grn->warehouse == $warehouse) {
                // GRN Header Row
                $resultArray[] = [
                    'Field1' => $this->trans('Date', '日期') . ' : ' . $this->convertDate($grn->grn_date),
                    'Field2' => $this->trans('GRN No.', '进货编号') . ' : ' . $grn->grn_no,
                    'Field3' => '',
                    'Field4' => '',
                    'Field5' => $this->trans('Incoming Quantity', '入仓数量') . ' : ' . $grn->qty,
                    'Field6' => '#060818',
                    'Field7' => 0,
                    'Field8' => $dateNumber,
                ];

                // Warehouse Row
                $resultArray[] = [
                    'Field1' => '',
                    'Field2' => $this->trans('Receiving Warehouse', '进仓仓库') . ' : ' . $warehouseName,
                    'Field3' => '',
                    'Field4' => '',
                    'Field5' => '',
                    'Field6' => 'transparent',
                    'Field7' => 1,
                    'Field8' => $dateNumber,
                ];

                // Invoice Details for this GRN
                $this->getInvoiceDetails($grn->id, $itemCode, $warehouse, $resultArray);

                // Unshipped Allocated Quantity
                $this->getUnshippedAllocated($grn->id, $itemCode, $warehouse, $resultArray);
            }
        }
    }
    protected function getInvoiceDetails($grnId, $itemCode, $warehouse, &$resultArray){
        $invoiceDetails = Invoice_detail::with(['product'])
            ->where('grn_detail_id', $grnId)
            ->whereHas('product', function ($query) use ($itemCode) {
                $query->where('product_code', $itemCode);
            })
            ->get()
            ->sortByDesc(function ($invoice) {
                return Carbon::parse($invoice->invoice_date)->format('Ymd');
            });

        foreach ($invoiceDetails as $invoice) {
            $invoiceNo = $invoice->invoice_no;

            // Shipout Headers
            $this->getShipoutHeaders($invoiceNo, $itemCode, $warehouse, $resultArray);

            // Shipout Items
            $this->getShipoutItems($invoiceNo, $itemCode, $warehouse, $resultArray);
        }
    }
    protected function getShipoutHeaders($invoiceNo, $itemCode, $warehouse, &$resultArray){
        $shipoutDates = Shipout_items::with(['product'])
            ->where('invoice_no', $invoiceNo)
            ->whereIn('status', [1, 2])
            ->whereHas('product', function ($query) use ($itemCode) {
                $query->where('product_code', $itemCode);
            })
            ->get()
            ->groupBy(function ($item) {
                return Carbon::parse($item->date)->format('Y-m-d');
            })
            ->sortByDesc(function ($group, $date) {
                return Carbon::parse($date)->format('Ymd');
            });

        foreach ($shipoutDates as $date => $items) {
            $dateNumber = Carbon::parse($date)->format('Ymd');
            $formattedDate = Carbon::parse($date)->format('M d Y');

            $resultArray[] = [
                'Field1' => $this->trans('Date', '日期') . ' : ' . $this->convertDate($formattedDate),
                'Field2' => $this->trans('Shipped Tracking No', '快递单号'),
                'Field3' => $this->trans('Customer Code', '客户编号'),
                'Field4' => $this->trans('Customer Name', '客户名'),
                'Field5' => $this->trans('Quantity', '数量'),
                'Field6' => '#060818',
                'Field7' => 6,
                'Field8' => $dateNumber,
            ];
        }
    }
    protected function getShipoutItems($invoiceNo, $itemCode, $warehouse, &$resultArray){
        $shipoutItems = Shipout_items::with(['customer', 'courier', 'shippingStatus', 'product'])
            ->where('invoice_no', $invoiceNo)
            ->whereIn('status', [1, 2])
            ->whereHas('product', function ($query) use ($itemCode) {
                $query->where('product_code', $itemCode);
            })
            ->get()
            ->unique('shipping_no')
            ->sortByDesc(function ($item) {
                return Carbon::parse($item->date)->format('Ymd') . '-' . $item->id;
            });

        foreach ($shipoutItems as $item) {
            $courier = $this->getCourierName($item->courier);
            $shippingStat = $this->getShippingStatName($item->shippingStatus);
            $dateNumber = Carbon::parse($item->date)->format('Ymd');

            $resultArray[] = [
                'Field1' => '',
                'Field2' => $item->tracking . ' - ' . $courier . ' - ' . $shippingStat . '<br>' . $item->invoice_no,
                'Field3' => $item->customer->customer_code ?? '',
                'Field4' => $item->customer->account_name_en ?? '',
                'Field5' => $item->qty,
                'Field6' => 'transparent',
                'Field7' => $item->id,
                'Field8' => $dateNumber,
            ];
        }
    }
    protected function getUnshippedAllocated($grnId, $itemCode, $warehouse, &$resultArray){
        $hasUnshipped = Inventory_allocation::with(['customer', 'shippingStat', 'product'])
            ->where('grn_detail_id', $grnId)
            ->where('warehouse', $warehouse)
            ->whereRaw('LENGTH(invoice_no) < 3 OR invoice_no IS NULL')
            ->whereHas('product', function ($query) use ($itemCode) {
                $query->where('product_code', $itemCode);
            })
            ->exists();

        if (!$hasUnshipped) {
            return;
        }

        // Header
        $resultArray[] = [
            'Field1' => $this->trans('Unship allocated quantity', '已分配未发数量'),
            'Field2' => '',
            'Field3' => $this->trans('Customer Code', '客户编号'),
            'Field4' => $this->trans('Customer Name', '客户名'),
            'Field5' => $this->trans('Quantity', '数量'),
            'Field6' => '#060818',
            'Field7' => 8,
            'Field8' => 999999999999999,
        ];

        // Details
        $allocations = Inventory_allocation::with(['customer', 'shippingStat', 'product'])
            ->where('grn_detail_id', $grnId)
            ->where('warehouse', $warehouse)
            ->whereRaw('LENGTH(invoice_no) < 3 OR invoice_no IS NULL')
            ->whereHas('product', function ($query) use ($itemCode) {
                $query->where('product_code', $itemCode);
            })
            ->orderByDesc('id')
            ->get();

        $totalAllocated = 0;

        foreach ($allocations as $alloc) {
            $resultArray[] = [
                'Field1' => '',
                'Field2' => '',
                'Field3' => $alloc->customer->customer_code,
                'Field4' => $alloc->customer->account_name_en ?? '',
                'Field5' => $alloc->qty,
                'Field6' => 'transparent',
                'Field7' => 9,
                'Field8' => 999999999999999,
            ];
            $totalAllocated += $alloc->qty;
        }

        // Total Row
        $resultArray[] = [
            'Field1' => '',
            'Field2' => '',
            'Field3' => '',
            'Field4' => $this->trans('Total Allocated quantity', '已分配总数'),
            'Field5' => $totalAllocated,
            'Field6' => '#060818',
            'Field7' => 10,
            'Field8' => 999999999999999,
        ];
    }
    protected function getInternalTransferIncomingHeaders($itemCode, $warehouse, &$resultArray){
        $transfers = Internal_Transfer::with(['whTo', 'product']) // include 'product' to avoid N+1
            ->whereHas('product', function ($query) use ($itemCode) {
                $query->where('product_code', $itemCode);
            })
            ->where('warehouse_to', $warehouse)
            ->get()
            ->groupBy(function ($transfer) {
                return Carbon::parse($transfer->transfer_date)->format('Y-m-d');
            })
            ->sortByDesc(function ($group, $date) {
                return Carbon::parse($date)->format('Ymd');
            });

        foreach ($transfers as $date => $group) {
            $transfer = $group->first();
            $dateNumber = Carbon::parse($date)->format('Ymd');

            $resultArray[] = [
                'Field1' => $this->trans('Date', '日期') . ' : ' . $this->convertDate($transfer->transfer_date),
                'Field2' => $this->trans('Internal Transfer No', '快递单号') . ' : ' . $transfer->transfer_no,
                'Field3' => '',
                'Field4' => '',
                'Field5' => $this->trans('Incoming Quantity', '入仓数量') . ' : ' . $transfer->qty,
                'Field6' => '#060818',
                'Field7' => 0,
                'Field8' => $dateNumber,
            ];
        }
    }
    protected function getInternalTransferIncomingDetails($itemCode, $warehouse, &$resultArray){
        $transfers = Internal_Transfer::with(['whTo', 'product']) // Make sure 'product' is eager-loaded
            ->whereHas('product', function ($query) use ($itemCode) {
                $query->where('product_code', $itemCode);
            })
            ->where('warehouse_to', $warehouse)
            ->orderBy('created_at', 'asc')
            ->get();

        foreach ($transfers as $transfer) {
            $warehouseName = $this->getWarehouseName($transfer->whTo);
            $dateNumber = Carbon::parse($transfer->created_at)->format('Ymd');

            $resultArray[] = [
                'Field1' => '',
                'Field2' => $this->trans('Receiving Warehouse', '进仓仓库') . ' : ' . $warehouseName,
                'Field3' => '',
                'Field4' => '',
                'Field5' => '',
                'Field6' => 'transparent',
                'Field7' => 1,
                'Field8' => $dateNumber,
            ];
        }
    }
    protected function getInternalTransferOutgoingHeaders($itemCode, $warehouse, &$resultArray){
        $transfers = Internal_Transfer::with('product')
            ->whereHas('product', function ($query) use ($itemCode) {
                $query->where('product_code', $itemCode);
            })
            ->where('warehouse_from', $warehouse)
            ->where('qty', '>', 0)
            ->get()
            ->groupBy(function ($transfer) {
                return Carbon::parse($transfer->transfer_date)->format('Y-m-d');
            });

        if ($transfers->isEmpty()) {
            return;
        }

        foreach ($transfers->sortByDesc(function ($group, $date) {
            return Carbon::parse($date)->format('Ymd');
        }) as $date => $group) {
            $transfer = $group->first();
            $dateNumber = Carbon::parse($date)->format('Ymd');

            $resultArray[] = [
                'Field1' => $this->trans('Date', '日期') . ' : ' . $this->convertDate($transfer->transfer_date),
                'Field2' => $this->trans('Internal Transfer No', '快递单号'),
                'Field3' => $this->trans('Transfer From', '客户编号'),
                'Field4' => $this->trans('Transfer To', '客户名'),
                'Field5' => $this->trans('Quantity', '数量'),
                'Field6' => '#060818',
                'Field7' => 11,
                'Field8' => $dateNumber,
            ];
        }
    }
    protected function getInternalTransferOutgoingDetails($itemCode, $warehouse, &$resultArray){
        $transfers = Internal_Transfer::with('product')
            ->whereHas('product', function ($query) use ($itemCode) {
                $query->where('product_code', $itemCode);
            })
            ->where('warehouse_from', $warehouse)
            ->where('qty', '>', 0)
            ->orderBy('created_at', 'asc')
            ->get();

        foreach ($transfers as $transfer) {
            $dateNumber = Carbon::parse($transfer->created_at)->format('Ymd');
            $isInTransit = $transfer->is_confirmed == 1 ? 'In-Transit' : '';
            $field3 = $transfer->is_confirmed == 1 
                ? $transfer->warehouse_from . ' - ' . $isInTransit 
                : $transfer->warehouse_from;

            $resultArray[] = [
                'Field1' => '',
                'Field2' => $transfer->transfer_no,
                'Field3' => $field3,
                'Field4' => $transfer->warehouse_to,
                'Field5' => $transfer->qty,
                'Field6' => 'transparent',
                'Field7' => 12,
                'Field8' => $dateNumber,
            ];
        }
    }
    protected function getInternalTransferToWarehouseHeaders($itemCode, $warehouse, &$resultArray){
        $transfers = Internal_Transfer::with('product')
            ->whereHas('product', function ($query) use ($itemCode) {
                $query->where('product_code', $itemCode);
            })
            ->where('warehouse_to', $warehouse)
            ->where('qty', '>', 0)
            ->get()
            ->groupBy(function ($transfer) {
                return Carbon::parse($transfer->transfer_date)->format('Y-m-d');
            });

        if ($transfers->isEmpty()) {
            return;
        }

        foreach ($transfers->sortByDesc(function ($group, $date) {
            return Carbon::parse($date)->format('Ymd');
        }) as $date => $group) {
            $transfer = $group->first();
            $dateNumber = Carbon::parse($date)->format('Ymd');

            $resultArray[] = [
                'Field1' => $this->trans('Date', '日期') . ' : ' . $this->convertDate($transfer->transfer_date),
                'Field2' => $this->trans('Internal Transfer No', '快递单号'),
                'Field3' => $this->trans('Transfer From', '客户编号'),
                'Field4' => $this->trans('Transfer To', '客户名'),
                'Field5' => $this->trans('Quantity', '数量'),
                'Field6' => '#060818',
                'Field7' => 13,
                'Field8' => $dateNumber,
            ];
        }
    }
    protected function getInternalTransferToWarehouseDetails($itemCode, $warehouse, &$resultArray){
        $transfers = Internal_Transfer::with(['product'])
            ->whereHas('product', function ($query) use ($itemCode) {
                $query->where('product_code', $itemCode);
            })
            ->where('warehouse_to', $warehouse)
            ->where('qty', '>', 0)
            ->orderBy('created_at', 'asc')
            ->get();

        foreach ($transfers as $transfer) {
            $dateNumber = Carbon::parse($transfer->created_at)->format('Ymd');
            $isInTransit = $transfer->is_confirmed == 1 ? 'In-Transit' : '';
            $field3 = $transfer->is_confirmed == 1 
                ? $transfer->warehouse_from . ' - ' . $isInTransit 
                : $transfer->warehouse_from;

            $resultArray[] = [
                'Field1' => '',
                'Field2' => $transfer->transfer_no,
                'Field3' => $field3,
                'Field4' => $transfer->warehouse_to,
                'Field5' => $transfer->qty,
                'Field6' => 'transparent',
                'Field7' => 14,
                'Field8' => $dateNumber,
            ];
        }
    }
    protected function getInventoryWithdrawalHeaders($itemCode, $warehouse, &$resultArray){
        $withdrawals = Inventory_allocation::with(['product'])
            ->whereNotNull('account_no')
            ->where('account_no', '!=', '')
            ->whereHas('product', function ($query) use ($itemCode) {
                $query->where('product_code', $itemCode);
            })
            ->where('warehouse', $warehouse)
            ->get()
            ->groupBy(function ($item) {
                return Carbon::parse($item->updated_at)->format('Ymd');
            })
            ->sortBy(function ($group, $date) {
                return $date;
            });

        foreach ($withdrawals as $date => $group) {
            $item = $group->first();
            $formattedDate = Carbon::parse($item->updated_at)->format('M d Y');

            $resultArray[] = [
                'Field1' => $this->trans('Date', '日期') . ' : ' . $this->convertDate($formattedDate),
                'Field2' => $this->trans('Inventory Withdrawal', '快递单号'),
                'Field3' => '',
                'Field4' => '',
                'Field5' => $this->trans('Quantity', '数量'),
                'Field6' => '#060818',
                'Field7' => 15,
                'Field8' => $date,
            ];
        }
    }
    protected function getInventoryWithdrawalDetails($itemCode, $warehouse, &$resultArray){
        $withdrawals = Inventory_allocation::with(['product', 'chartAccount'])
            ->whereNotNull('account_no')
            ->where('account_no', '!=', '')
            ->whereHas('product', function ($query) use ($itemCode) {
                $query->where('product_code', $itemCode);
            })
            ->where('warehouse', $warehouse)
            ->get();

        foreach ($withdrawals as $item) {
            $dateNumber = Carbon::parse($item->updated_at)->format('Ymd');

            $resultArray[] = [
                'Field1' => '',
                'Field2' => $item->chartAccount->account_name ?? '',
                'Field3' => '',
                'Field4' => '',
                'Field5' => $item->qty,
                'Field6' => 'transparent',
                'Field7' => 16,
                'Field8' => $dateNumber,
            ];
        }
    }
    protected function sortAndDeduplicate($resultArray){
        usort($resultArray, function ($a, $b) {
            $dateDiff = $a['Field8'] - $b['Field8'];
            if ($dateDiff != 0) return $dateDiff;
            return $a['Field7'] - $b['Field7'];
        });
        return array_values(array_unique($resultArray, SORT_REGULAR));
    }
    protected function trans($en, $cn){
        return $this->language == 'en' ? $en : $cn;
    }
    protected function getWarehouseName($warehouse){
        if (!$warehouse) return '';
        
        if ($this->language == 'en') {
            return $warehouse->warehouse_en ?? '';
        }
        return !empty($warehouse->warehouse_cn) 
            ? $warehouse->warehouse_cn 
            : ($warehouse->warehouse_en ?? '');
    }
    protected function getCourierName($courier){
        if (!$courier) return '';
        return $this->language == 'en' 
            ? ($courier->courier_en ?? '') 
            : ($courier->courier_cn ?? '');
    }
    protected function getShippingStatName($stat){
        if (!$stat) return '';
        return $this->language == 'en' 
            ? ($stat->shipping_stat_en ?? '') 
            : ($stat->shipping_stat_cn ?? '');
    }
    protected function getCopySvg($data){
        return '';
    }
    protected function convertDate($date){
        return $date;
    }
    public function getInternalTransfer(Request $request, $type){
        $perPage = (int) $request->input('per_page', 15);
        $search = $request->input('search', '');

        if($type === 'outgoing'){
            $query = Internal_Transfer::with(['whTo', 'product','sender','receiver'])
                ->where('is_confirmed',1)
                ->where('is_deleted', 0);
        }
        if($type === 'incoming'){
            $query = Internal_Transfer::with(['whTo', 'product','sender','receiver'])
                ->where('is_confirmed',1)
                ->where('is_deleted', 0);
        }
        if($type === 'historical'){
            $query = Internal_Transfer::with(['whTo', 'product','sender','receiver'])
                ->where('is_confirmed',0)
                ->where('is_deleted', 0);
        }
        if($type === 'archive'){
            $query = Internal_Transfer::with(['whTo', 'product','sender','receiver'])
                ->where('is_confirmed',1)
                ->where('is_deleted', 1);
        }
        if (!empty($search)) {
            $query->where(function ($q) use ($search) {
                $q->whereRaw("CONCAT(transfer_no, '-', transfer_ext) LIKE ?", ["%{$search}%"])
                ->orWhereHas('product', function ($q2) use ($search) {
                    $q2->where('product_code', 'like', "%{$search}%")
                        ->orWhere('product_title_en', 'like', "%{$search}%")
                        ->orWhere('product_title_cn', 'like', "%{$search}%");
                });
            });
        }

        $allTransfers = $query->get();

        // Group transfers by transfer_no + transfer_ext
        $grouped = $allTransfers
            ->groupBy(function ($item) {
                return $item->transfer_no . '-' . $item->transfer_ext;
            })
            ->sortKeysDesc();

        // Transform each grouped transfer with embedded details
        $transformed = $grouped->map(function ($groupItems, $key) {
            // Use the first item as base
            $first = $groupItems->first();

            return [
                'id' => $first->id,
                'ftransfer_no' => $key,
                'transfer_no' => $first->transfer_no,
                'transfer_ext' => $first->transfer_ext,
                'transfer_date' => $first->transfer_date,
                'user_id' => optional($first->sender)->username,
                'receiver_id' => optional($first->receiver)->username,
                'received_date' => $first->received_date,
                'warehouse_from' => $first->warehouse_from,
                'warehouse_to' => $first->warehouse_to,
                'warehouse_to_text_en' => optional($first->whTo)->warehouse_en,
                'warehouse_to_text_cn' => optional($first->whTo)->warehouse_cn,
                'product_code' => optional($first->product)->product_code,
                'product_title_en' => optional($first->product)->product_title_en,
                'product_title_cn' => optional($first->product)->product_title_cn,
                'details' => $groupItems->map(function ($item) {
                    $inv = Inventory_tblmaster::where('product_id', $item->product_id)
                        ->where('warehouse', $item->warehouse_from)
                        ->first();

                    if ($inv) {
                        $rem_qty = $inv->qty - $inv->allocated_qty;
                    } else {
                        $rem_qty = 0; // or handle it appropriately
                    }

                    $grnDetail = Grn_details::where('product_id', $item->product_id)
                        ->where('warehouse', $item->warehouse_from)
                        ->get();

                    $received_qty = $grnDetail->sum('qty') ?? 0;

                    return [
                        'id' => $item->id,
                        'product_code' => optional($item->product)->product_code,
                        'product_title_en' => optional($item->product)->product_title_en,
                        'product_title_cn' => optional($item->product)->product_title_cn,
                        'qty' => $item->qty,
                        'inventory_id' => $item->inventory_id,
                        'rem_qty' => $rem_qty,
                        'received_qty' => $received_qty,
                        'warehouse_from' => $item->warehouse_from,
                        'warehouse_to' => $item->warehouse_to,
                        'transfer_date' => $item->transfer_date,
                        'received_date' => $item->received_date,
                    ];
                })->values(),
            ];
        })->values(); // reset index

        // Manual pagination
        if ($perPage === -1) {
            $response = [
                'current_page' => 1,
                'data' => $transformed,
                'last_page' => 1,
                'per_page' => $transformed->count(),
                'total' => $transformed->count(),
            ];
        } else {
            $page = LengthAwarePaginator::resolveCurrentPage();
            $paginated = new LengthAwarePaginator(
                $transformed->forPage($page, $perPage),
                $transformed->count(),
                $perPage,
                $page,
                ['path' => request()->url(), 'query' => request()->query()]
            );

            $response = $paginated;
        }

        return response()->json([
            'success' => true,
            'message' => 'Success',
            'list' => $response,
        ]);
    }
    public function getInternalInventory(Request $request){
        $perPage = (int) $request->input('per_page', 15);
        $search = $request->input('search', '');
        $sortId = $request->input('sortId', []);
        // If sortId is not an array, convert it to an array
        if (!is_array($sortId)) {
            $sortId = explode(',', $sortId);  // Convert comma-separated string to array
        }
        // Build the query
        $query = Inventory_tblmaster::with('product')
            ->whereRaw('qty - allocated_qty > 0')
            ->whereHas('product', function ($q) {
                $q->where('is_deleted', 0);
            }); // Add this line

        if (!empty($sortId)) {
            // Apply the FIELD(id, ...) sorting first, without the second `orderBy('id', 'desc')`
            $query->orderByRaw("FIELD(id, " . implode(',', $sortId) . ") DESC");
        } else {
            // If no sortId is provided, use default descending order by `id`
            $query->orderBy('id', 'desc');
        }

        // Apply search
        if (!empty($search)) {
            $query->where(function ($q) use ($search) {
                $q->where('warehouse', 'like', "%{$search}%")
                    ->orWhereHas('product', function ($q2) use ($search) {
                        $q2->where('product_code', 'like', "%{$search}%")
                            ->orWhere('product_title_en', 'like', "%{$search}%")
                            ->orWhere('product_title_cn', 'like', "%{$search}%");
                    });
            });
        }

        // Get the results
        $results = $perPage === -1 ? $query->get() : $query->paginate($perPage);

        // Transform each item
        $transform = function ($item) {
            $InTransitQty = Internal_Transfer::where('product_id',$item->product_id)
                ->where('is_confirmed',1)->sum('qty') ?? 0;

            return [
                'id' => $item->id,
                'product_id' => $item->product_id,
                'product_code' => optional($item->product)->product_code,
                'product_title_en' => optional($item->product)->product_title_en,
                'product_title_cn' => optional($item->product)->product_title_cn,
                'rem_qty' => $item->qty - $item->allocated_qty,
                'item_cost' => optional($item->product)->item_cost,
                'warehouse' => $item->warehouse,
                'in_transit_qty' => $InTransitQty,
            ];
        };

        if ($perPage === -1) {
            $data = $results->map($transform);
            $response = [
                'current_page' => 1,
                'data' => $data,
                'last_page' => 1,
                'per_page' => $data->count(),
                'total' => $data->count(),
            ];
        } else {
            $results->getCollection()->transform($transform);
            $response = $results;
        }

        return response()->json([
            'success' => true,
            'message' => 'Success',
            'list' => $response,
        ]);
    }
    public function delTransfer(Request $request){
        $details = $request->input('details');

        if (!is_array($details) || empty($details)) {
            return response()->json(['message' => 'No product IDs provided'], 400);
        }

        foreach ($details as $list) {
            $transfers = Internal_Transfer::where('transfer_no', $list['transfer_no'])
                ->where('transfer_ext', $list['transfer_ext'])
                ->get();

            foreach ($transfers as $transfer) {
                $ftransfer_no = $transfer->transfer_no . '-' . $transfer->transfer_ext;

                // Perform delete
                $transfer->is_deleted = 1;
                $transfer->save();

                // Log action
                $globalController = new GlobalController();
                $globalController->logAction(
                    'Internal Transfer',
                    't_internal_transfer',
                    'delete',
                    'Product Code: ' . $ftransfer_no
                );
            }
        }

        return response()->json(['message' => 'Transfer(s) deleted']);
    }
    public function saveTransfer(Request $request){
        $details = $request->input('details');
        $no = $request->input('no');
        $ext = $request->input('ext');
        
        if (!is_array($details) || empty($details)) {
            return response()->json(['message' => 'No product IDs provided'], 400);
        }

        $AutoGenerated = new AutoGenerated();
        $transfer_no = $AutoGenerated->getNextNo("transfer_no","INT-","t_internal_transfer");

        if (strlen($no) > 3){
            $transfers = Internal_Transfer::where('transfer_no', $no)
                ->where('transfer_ext', $ext)
                ->get();

            $transfer_no = $no;
            
            foreach ($transfers as $transfer) {
                $transfer->delete();
            }
        }

        $cntExt = 0;
        $newWH = '';
        $details = collect($details)->sortBy('to')->values()->all();

        foreach ($details as $list) {
            if ($newWH != $list['to']){
                $cntExt++;           
            }
            $newWH = $list['to'];
            $transfer_ext = (strlen($no) > 3 ? $ext : $this->getExtension($cntExt - 1));

            $insert_master = [
                'transfer_no' => $transfer_no,
                'transfer_ext' => $transfer_ext,
                'transfer_date' => date('M d Y'),
                'product_id' => $list['product_id'],
                'warehouse_from' => $list['warehouse'],
                'warehouse_to' => $list['to'],
                'qty' => $list['new_qty'],
                'inventory_id' => $list['id'],
                'user_id' => 68,
            ];

            Internal_Transfer::create($insert_master);
        }

        return response()->json(['message' => 'alert_message_114']);
    }
    public function getExtension($index) {
        $letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
        return $letters[$index] ?? '';
    }
    public function confirmTransfer(Request $request){
        $master = $request->input('details');
        $userId = 68;

        if (!is_array($master) || empty($master)) {
            return response()->json(['message' => 'No product IDs provided']);
        }

        foreach ($master as $list) {
           $details = $list['details'];
            foreach ($details as $item) {
                
                $transferId = $item['id'];
                $warehouseTo = $item['warehouse_to'];
                $inventoryId = $item['inventory_id'];
                $qty = $item['qty'];
                $receivedDate = date('M d Y');

                $transfer = Internal_Transfer::findOrFail($transferId);
                $transfer->update([
                    'remqty' => DB::raw('remqty - qty'),
                    'is_confirmed' => 0,
                    'receiver_id' => $userId,
                    'received_date' => $receivedDate,
                ]);

                $this->updateProductRemQty($transfer->product_id);

                $ProductStatusService = new ProductStatusService();
                $ProductStatus = $ProductStatusService->getProductStatus($transfer->product_id);
                Products::where('id', $transfer->product_id)->update([
                    'product_status' => $ProductStatus
                ]);

                // 2. Destination inventory exists?
                $destinationInv = Inventory_tblmaster::where('product_id', $transfer->product_id)
                    ->where('warehouse', $warehouseTo)
                    ->first();

                // 3. Source inventory (being transferred out)
                $sourceInv = Inventory_tblmaster::findOrFail($inventoryId);

                if ($destinationInv) {
                    // Update destination inventory (add qty)
                    $destinationInv->increment('qty', $qty);

                    $remainingQty = $sourceInv->qty - $qty;

                    if ($remainingQty > 0) {
                        $sourceInv->decrement('qty', $qty);
                    } else {
                        $sourceInv->delete();
                    }
                } else {
                    // Destination doesn't exist — create it
                    $sourceInv->decrement('qty', $qty);

                    Inventory_tblmaster::create([
                        'product_id' => $transfer->product_id,
                        'qty' => $qty,
                        'allocated_qty' => 0,
                        'warehouse' => $warehouseTo,
                        'physical_qty' => 0, // or null/default
                        'from_grn' => null,  // or default value
                    ]);
                }
            }
        }

        return response()->json(['message' => 'alert_message_114']);
    }
    public function getAllStockTake(Request $request){
        $perPage = (int) $request->input('per_page', 15);
        $page = (int) $request->input('page', 1);
        $search = $request->input('search', '');
        $dateFrom = $request->input('date_from');
        $dateTo = $request->input('date_to');

        // Base query with eager loading
        $query = Stock_take_master::with([
            'details.product:id,product_code,product_title_en,product_title_cn'
        ])->orderByDesc('id');

        // Filters
        if ($dateFrom && $dateTo) {
            $query->whereBetween('date', [$dateFrom, $dateTo]);
        }

        if (!empty($search)) {
            $query->where(function ($q) use ($search) {
                $q->where('st_no', 'like', "%{$search}%")
                    ->orWhereHas('details.product', function ($q) use ($search) {
                        $q->where('product_code', 'like', "%{$search}%")
                            ->orWhere('product_title_en', 'like', "%{$search}%")
                            ->orWhere('product_title_cn', 'like', "%{$search}%");
                    });
            });
        }

        // Clone query to calculate totals for footer
        $allData = (clone $query)->get();

        // Flat map and sum all quantities
        $totalQty = $allData->flatMap(fn($master) => $master->details)->sum('qty');
        $totalPhysicalQty = $allData->flatMap(fn($master) => $master->details)->sum('physical_qty');

        $footer = [
            'total_qty' => $totalQty,
            'total_physical_qty' => $totalPhysicalQty,
        ];

        // Paginate or get all
        $result = $perPage === -1 ? $query->get() : $query->paginate($perPage);

        // Transform if needed
        $paginatedData = $perPage === -1
            ? $result->map(fn($item) => $this->transformStockTakeData($item))
            : tap($result)->getCollection()->transform(fn($item) => $this->transformStockTakeData($item));

        // Return JSON response
        return response()->json([
            'success' => true,
            'message' => 'success',
            'list' => [
                'current_page' => $result instanceof LengthAwarePaginator ? $result->currentPage() : 1,
                'data' => $paginatedData,
                'footer' => $footer,
                'last_page' => $result instanceof LengthAwarePaginator ? $result->lastPage() : 1,
                'per_page' => $result instanceof LengthAwarePaginator ? $result->perPage() : $paginatedData->count(),
                'total' => $result instanceof LengthAwarePaginator ? $result->total() : $paginatedData->count(),
            ]
        ]);
    }
    protected function transformStockTakeData($item){
        return [
            'id' => $item->id,
            'st_no' => $item->st_no,
            'date' => $item->date,
            'location' => $item->location,
            'details' => $item->details->map(fn($d) => [
                'id' => $d->id,
                'product_id' => $d->product_id,
                'qty' => $d->qty,
                'physical_qty' => $d->physical_qty,
                'warehouse' => $d->location,
                'product_code' => $d->product->product_code ?? "",
                'product_title_en' => $d->product->product_title_en ?? "",
                'product_title_cn' => $d->product->product_title_cn ?? "",
            ]),
        ];
    }
    public function getStockTakeInventory(Request $request){
        $perPage = (int) $request->input('per_page', 15);
        $search = $request->input('search', '');
        $sortId = $request->input('sortId', []);
        // If sortId is not an array, convert it to an array
        if (!is_array($sortId)) {
            $sortId = explode(',', $sortId);  // Convert comma-separated string to array
        }
        $sortId = array_filter(array_map('intval', $sortId));
        // Build the query
        $query = Inventory_tblmaster::with('product')
            ->whereRaw('qty - allocated_qty > 0')
            ->whereHas('product', function ($q) {
                $q->where('is_deleted', 0);
            }); // Add this line

        if (!empty($sortId)) {
            // Apply the FIELD(id, ...) sorting first, without the second `orderBy('id', 'desc')`
            $query->orderByRaw("FIELD(product_id, " . implode(',', $sortId) . ") DESC");
        } else {
            // If no sortId is provided, use default descending order by `id`
            $query->orderBy('id', 'desc');
        }

        // Apply search
        if (!empty($search)) {
            $query->where(function ($q) use ($search) {
                $q->where('warehouse', 'like', "%{$search}%")
                    ->orWhereHas('product', function ($q2) use ($search) {
                        $q2->where('product_code', 'like', "%{$search}%")
                            ->orWhere('product_title_en', 'like', "%{$search}%")
                            ->orWhere('product_title_cn', 'like', "%{$search}%");
                    });
            });
        }

        // Get the results
        $results = $perPage === -1 ? $query->get() : $query->paginate($perPage);

        // Transform each item
        $transform = function ($item) {
            $InTransitQty = Internal_Transfer::where('product_id',$item->product_id)
                ->where('is_confirmed',1)->sum('qty') ?? 0;

            return [
                'id' => $item->id,
                'product_id' => $item->product_id,
                'product_code' => optional($item->product)->product_code,
                'product_title_en' => optional($item->product)->product_title_en,
                'product_title_cn' => optional($item->product)->product_title_cn,
                'rem_qty' => $item->qty - $item->allocated_qty,
                'item_cost' => optional($item->product)->item_cost,
                'warehouse' => $item->warehouse,
                'in_transit_qty' => $InTransitQty,
            ];
        };

        if ($perPage === -1) {
            $data = $results->map($transform);
            $response = [
                'current_page' => 1,
                'data' => $data,
                'last_page' => 1,
                'per_page' => $data->count(),
                'total' => $data->count(),
            ];
        } else {
            $results->getCollection()->transform($transform);
            $response = $results;
        }

        return response()->json([
            'success' => true,
            'message' => 'Success',
            'list' => $response,
        ]);
    }
    public function saveStockTake(Request $request){
        $details = $request->input('details');
        $id = $request->input('id');

        if (!is_array($details) || empty($details)) {
            return response()->json(['message' => 'No product IDs provided'], 400);
        }

        // Determine location string
        $locations = collect($details)->pluck('location')->unique();
        $location = $locations->count() === 1 ? $locations->first() : 'Multiple';

        // Create new stock take
        if ((int)$id === 0) {
            $AutoGenerated = new AutoGenerated();
            $st_no = $AutoGenerated->getNextNo("st_no", "ST", "t_stock_take_master");

            // Insert master
            Stock_take_master::create([
                'st_no' => $st_no,
                'date' => now()->format('Y-m-d'),
                'location' => $location,
            ]);
        } else {
            $master = Stock_take_master::find($id);
            if (!$master) {
                return response()->json(['message' => 'Stock take not found'], 404);
            }

            $st_no = $master->st_no;

            // Update master location
            $master->update([
                'location' => $location,
            ]);
        }

        // Save or update stock take details
        foreach ($details as $item) {
            Stock_take_detail::updateOrCreate(
                [
                    'st_no' => $st_no,
                    'product_id' => $item['product_id'],
                ],
                [
                    'date' => now()->format('Y-m-d'),
                    'location' => $item['location'],
                    'qty' => $item['qty'],
                    'physical_qty' => $item['physical_qty'],
                ]
            );
        }

        return response()->json([
            'message' => 'alert_message_114',
            'st_no' => $st_no,
        ]);
    }
    public function delStockTake(Request $request){
        $ids = $request->input('ids');

        if (!is_array($ids) || empty($ids)) {
            return response()->json(['message' => 'No IDs provided'], 400);
        }

        foreach ($ids as $id) {
            $master = Stock_take_master::where('id', $id)->first();
            $master->delete();
            // Log action
            $globalController = new GlobalController();
            $globalController->logAction(
                'Stock Take',
                't_stock_take_master',
                'delete',
                'ST No: ' . $master->st_no
            );
        }

        return response()->json(['message' => 'Transfer(s) deleted']);
    }
    public function publishProductImports(Request $request){
        $details = $request->input('details');
        $baseCurrency = ISSettings::where('tag', 'basecurrency')->value('en');

        DB::beginTransaction();

        try {

            // Make sure it's a collection
            $grouped = collect($details)
                ->groupBy(function ($item) {
                    return $item['supplier_id'] . '|' . $item['rwarehouse'];
                })
                ->map(function ($group) use ($baseCurrency) {  // ← Add "use" here
                    $sum = $group->sum(function ($item) {
                        return $item['inventry_qty'] * $item['offered_cost'];
                    });

                    // Split the key
                    $first = $group->first();
                    $supplier_id = $first['supplier_id'];
                    $supplier_currency = $first['supplier_currency'];
                    $rwarehouse = $first['rwarehouse'];

                    $request2 = new Request([
                        'currency' => $supplier_currency,
                        'basecurrency' => $baseCurrency
                    ]);

                    $globalController = new GlobalController();
                    $globalResponse = $globalController->getCurrentExRate($request2);
                    $global = $globalResponse->getData();

                    return [
                        'supplier_id' => $supplier_id,
                        'supplier_currency' => $supplier_currency,
                        'warehouse' => $rwarehouse,
                        'ex_rate' => $global->ex_rate,
                        'total_cost' => $sum,
                        'details' => $group->values(), // ungrouped original items
                    ];
                })->values();

            // Save or update stock take details
            foreach ($grouped as $item) {
                $supplier_id = $item['supplier_id'];
                $currency = $item['supplier_currency'];
                $warehouse = $item['warehouse'];
                $ex_rate = $item['ex_rate'];
                $total = $item['total_cost'];
                $base_total = 0;
                $details = $item['details'];

                $AutoGenerated = new AutoGenerated();
                $grn_no = $AutoGenerated->getNextNo("grn_no","GRN","t_grn_master");
                $operator = Operator::where('convertion', $currency.$baseCurrency)->value('operator') ?? '';

                if($baseCurrency != $currency){
                    $base_total = $total;
                }
                else{
                    if($operator === 'Divide'){
                        $base_total = $total / $ex_rate;
                    }
                    if($operator === 'Multiply'){
                        $base_total = $total * $ex_rate;
                    }
                }

                $insertMaster = [
                    'grn_no' => $grn_no,
                    'supplier_id' => $supplier_id,
                    'warehouse' => $warehouse,
                    'shipping_Stat_id' => null,
                    'shipper_id' => null,
                    'grn_date' => date('M d Y'),
                    'ex_rate' => $ex_rate,
                    'company_id' => null,
                    'currency' => $currency,
                    'total' => $total,
                    'base_total' => $base_total,
                    'imported' => 1,
                    'grn_status_id' => 2,
                ];
                Grn_master::create($insertMaster);

                foreach ($details as $list) {
                    $product_id = $list['id'];
                    $insertDetail = [
                        'grn_no' => $grn_no,
                        'grn_date' => date('M d Y'),
                        'warehouse' => $warehouse,
                        'currency' => $currency,
                        'ex_rate' => $ex_rate,
                        'supplier_id' => $list['supplier_id'],
                        'product_id' => $product_id,
                        'cnt_weight' => 0,
                        'cartons' => 0,
                        'lcm' => 0,
                        'bcm' => 0,
                        'hcm' => 0,
                        'cbm' => 0,
                        'vweight' => 0,
                        'nw' => 0,
                        'po_number' => '',
                        'qty' => $list['inventry_qty'],
                        'price' => $list['offered_cost'],
                        'total' => $list['inventry_qty'] * $list['offered_cost'],
                        'item_cost' => $list['item_cost'],
                    ];

                    Grn_details::create($insertDetail);

                    Products::where('id', $product_id)->update([
                        'is_import' => 0,
                        'last_received_date' => date('M d Y')
                    ]);

                    $nItemCodeWH = Inventory_tblmaster::where('warehouse', $warehouse)
                        ->where('product_id', $product_id)
                        ->count();

                    $sumQty = Grn_details::where('warehouse', $warehouse)
                        ->where('product_id', $product_id)
                        ->sum('qty');

                    $sumInternalTransferQty = Inventory_tblmaster::where('product_id', $product_id)
                        ->where('from_grn', '!=', 1)
                        ->sum('qty');

                    $newReceiveQty = $sumQty - $sumInternalTransferQty;

                    if ($nItemCodeWH == 0) {
                        // Insert new record
                        Inventory_tblmaster::create([
                            'product_id' => $product_id,
                            'qty' => $newReceiveQty,
                            'warehouse' => $warehouse,
                            'from_grn' => 1,
                        ]);
                    } else {
                        // Update existing record
                        Inventory_tblmaster::where('warehouse', $warehouse)
                            ->where('product_id', $product_id)
                            ->where('from_grn', 1)
                            ->update(['qty' => $newReceiveQty]);
                    }

                    // Delete rows where Qty = 0
                    Inventory_tblmaster::where('qty', 0)->delete();

                }
            }

            event(new ProductEvent( 'insert'));
            event(new GRNEvent( 'insert'));
            event(new LogEvent( 'insert'));

            DB::commit(); // 👍 Success

            return response()->json([
                'token'     => 'Success',
                'message'   => 'Record Successfully Imported',
                'action'    => 'Confirm'
            ]);

        } catch (\Exception $e) {
            DB::rollBack(); // ❌ Failed

            return response()->json([
                'token'     => 'Error',
                'message'  => $e->getMessage(),
                'action'    => 'Confirm'
            ]);
        }
    }
}
